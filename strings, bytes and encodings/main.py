# Что есть символы, что есть коды символов и что такое кодировка?

# Каждый символ хранится в памяти компютера как некий код
# ord(char) - показать код символа
# chr(code) - показать символ, соответствующий коду

print(ord('h'))
print(chr(104))

# вот как хранится строка в памяти
for ch in 'hello':
    print(ord(ch))


codes = [104, 101, 108, 108, 111, ]

# можно её обратно из кодов собрать
out = ''
for code in codes:
    out += chr(code)
print(out)

# а какие вообще символы есть?
for code in range(128):
    print(code, hex(code), chr(code))
# получается таблица символов ASCII https://ru.wikipedia.org/wiki/ASCII

# то есть каждый символ имеет свой код. В пайтоне символы храняться в кодах unicode
# https://foxtools.ru/Unicode
# Эта таблица стандарт для ВСЕХ символов, которое придумало человечество

# Это именно стандарт, а не кодировка - сам по себе Юникод не определяет,
# как сиволы будут сохраняться на жестком диске или передаваться по сети.
# Он лишь определяет связь межлду символом и некоторым числом

for code in range(1000, 1200):
    print(code, chr(code))

# но коды символов больших чем байт (256) будут занимать несколько байт.
# Поэтому есть форматы представления текста - как хранить коды Юникода.
# например старший байт из двух/трех/етс идет первым или вторым?

# наиболее распространенным является представление UTF-8 - https://ru.wikipedia.org/wiki/UTF-8
# и в реальности на дисках наши тексты сохраняются в одном из форматов представления

# Как хранить не строки, но сами байты?
# В пайтоне есть типы данных, который позваляет хранить "сырые байты" - bytes

bb = b'\xd1\x84'
print(bb)

# Тип bytes очень похож на str
bb = b'\xd0\xbf\xd1\x80\xd0\xb2\xd0\xb5\xd1\x82'
print(bb)
print(type(bb))
# по сути это неизменяемые последовательности целых чисел,
# поддерживают теже операции что и str
print(bb[0])
print(bb.count(0xd0))
print(b'he' + b'llo')
#  полный список операций - https://goo.gl/7Cznir
# bytes - неизменяемые
# bb[0] = 110

# На самом деле это UTF-8 представление русской буквы. Какой? давайте разберем
# (на основе описания формата - https://goo.gl/Um4xUz)
bb = b'\xd1\x84'
print(bin(0xd1))
print(bin(0x84))
# 0b11010001
# 0b10000100
# код символа в юникоде занимает 2 байт, значит в превом байте будет 110 сначала, а во втором 10
# значащие биты 10001 и 000100
code = 0b10001000100
print(code)
print(hex(code))
# а это код русской буквы ф в юникоде
print(chr(code))
# элемнтарно, Ватсон!

# при выводе на терминал есть особенности
# латинские сиволы ASCII при выводе на термнал отображаются
# как символы, а не коды
bb = b'\x68\xd1\x84'
print(bb)
print(bb.hex())
# (видимо для удобства англоговорящих программистов)

# так же есть изменяемый (mutable) аналог bytes - это bytearray
ba = bytearray(b'hello')
ba[0] = 32 # код пробела
print(ba)
# создаваться bytearray может только через конструктор
print(bytearray())
print(bytearray(16))
print(bytearray(range(16)))
print(vytearray(b'hello'))
print(bytearray('привет', encoding='utf-8'))