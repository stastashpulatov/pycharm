# Что есть символы, что есть коды символов и что такое кодировка?

# Каждый символ хранится в памяти компютера как некий код
# ord(char) - показать код символа
# chr(code) - показать символ, соответствующий коду

print(ord('h'))
print(chr(104))

# вот как хранится строка в памяти
for ch in 'hello':
    print(ord(ch))


codes = [104, 101, 108, 108, 111, ]

# можно её обратно из кодов собрать
out = ''
for code in codes:
    out += chr(code)
print(out)

# а какие вообще символы есть?
for code in range(128):
    print(code, hex(code), chr(code))
# получается таблица символов ASCII https://ru.wikipedia.org/wiki/ASCII

# то есть каждый символ имеет свой код. В пайтоне символы храняться в кодах unicode
# https://foxtools.ru/Unicode
# Эта таблица стандарт для ВСЕХ символов, которое придумало человечество

# Это именно стандарт, а не кодировка - сам по себе Юникод не определяет,
# как сиволы будут сохраняться на жестком диске или передаваться по сети.
# Он лишь определяет связь межлду символом и некоторым числом

for code in range(1000, 1200):
    print(code, chr(code))

# но коды символов больших чем байт (256) будут занимать несколько байт.
# Поэтому есть форматы представления текста - как хранить коды Юникода.
# например старший байт из двух/трех/етс идет первым или вторым?

# наиболее распространенным является представление UTF-8 - https://ru.wikipedia.org/wiki/UTF-8
# и в реальности на дисках наши тексты сохраняются в одном из форматов представления

# Как хранить не строки, но сами байты?
# В пайтоне есть типы данных, который позваляет хранить "сырые байты" - bytes

bb = b'\xd1\x84'
print(bb)

# Тип bytes очень похож на str
bb = b'\xd0\xbf\xd1\x80\xd0\xb2\xd0\xb5\xd1\x82'
print(bb)
print(type(bb))
# по сути это неизменяемые последовательности целых чисел,
# поддерживают теже операции что и str
print(bb[0])
print(bb.count(0xd0))
print(b'he' + b'llo')
